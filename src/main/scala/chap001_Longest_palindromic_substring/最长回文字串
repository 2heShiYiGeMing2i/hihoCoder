   小 Hi 和小 Ho 是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。

   这一天，他们遇到了一连串的字符串，于是小 Hi 就向小 Ho 提出了那个经典的问题：“小 Ho，你能不能分别 在这些字符串中找到它们每一个的最长回文子串呢？”

   小 Ho 奇怪的问道：“什么叫做最长回文子串呢？”

   小 Hi 回答道：“一个字符串中连续的一段就是这个字符串的子串，而回文串指的是 12421 这种从前往后读和从后往前读一模一样的字符串，所以最长回文子串的意思就是这个字符串中最长的身为回文串的子串啦~”

   小 Ho 道：“原来如此！那么我该怎么得到这些字符串呢？我又应该怎么告诉你我所计算出的最长回文子串呢？

   小 Hi 笑着说道：“这个很容易啦，你只需要写一个程序，先从标准输入读取一个整数 N（N<=30)，代表我给你的字符串的个数，然后接下来的就是我要给你的那 N 个字符串（字符串长度 <=10^6) 啦。而你要告诉我你的答案的话，只要将你计算出的最长回文子串的长度按照我给你的顺序依次输出到标准输出就可以了！你看这就是一个例子。”



   良久，小 Ho 仍然没有头绪，于是只能向小 Hi 求助。

   小 Hi 清了清嗓子，缓缓说道：“让我从简单的说起吧， 我给你一个字符串，你能不能告诉我它是不是一个回文串呢？”

   小 Ho 回答道：“这个我当然可以啦！只要将这个字符串反过来，然后比较和原来的字符串是不是一样的不就行了？”

   小 Hi 追问道：“也就是说你想要新建一个字符串咯？”

   小 Ho 道：“那是当然，不然怎么比较呢？”

   小 Hi 笑道：“但是你有没有注意到你在比较原来的字符串 A 和新字符串 B 的时候，A 的第一个字符就是 B 的最后一个字符，而 A 的最后一个字符就是 B 的第一个字符，那么这样就比较了两次是不是浪费了效率呢？”

   小 Ho 恍然道：“似乎是这样的！我知道了，我也不需要新建一个字符串了， 我只需要比较 A 的第一个字符和最后一个字符是否相同，第二个字符和倒数第二个字符是否相同，以此类推，这样就只要比较字符串长度的一半次数就行了是不是？”

   小 Hi 回答道：“没错！那你 对于一个字符串，一一枚举它的子串，然后判断这个子串是不是回文子串，如果是的话就更新当前保存的最长的那一个，是不是就可以了？”

   小 Ho 开心道：“是的！这个问题是不是就这么解决了？”

   小 Hi 叹息道：“NONONO！你这 最多也就拿个 60 分吧。”

   小 Ho 遗憾的说道：“才及格啊，那我要怎么多拿点分呢？”

   提示二
   小 Hi 道：“不急不急，待我慢慢道来，你有没有想过之前的解法有没有什么问题？”

   小 Ho 问道：“有什么问题？”

   小 Hi 道：“你想想， 如果一个字符串的 [3, 7] 这一段已经不是回文子串了，[2, 8] 这一段还有可能是回文子串么？”

   小 Ho 惊道：“好像不可能，那我之前不是有很多的计算都白费了，有没有什么办法来解决这个问题呢？我得好好想想！” 言罢，小 Ho 沉思了起来。

   良久，代表着成功的微笑出现来的小 Ho 的嘴边：“我知道了！我在枚举子串的时候换一种方式来进行枚举， 不是枚举它的起止位置而是尝试枚举子串的中心位置，然后再从小到大依次枚举这个子串的长度，一旦发现已经不是一个回文串了就继续尝试下一个中心位置，这样，似乎就能够避免掉很多问题呢！”

   小 Hi 赞许的点了点头，说道：“没错，这样的确会在一些情况下降低用于计算的时间呢， 但是一个全是 a 的字符串，你这样的枚举方法似乎也没有多大用处呢？不过这样你也能拿个 80 分了哦！”

   小 Ho 点了点头，说道：“没错，在最坏情况下，这种方法并没有比之前的方法好到哪里去，但是我的直觉告诉我肯定有更加高效的方法来进行计算呢，让我再好好想想吧！。”

   提示三
   小 Ho 这一想就是三天，小 Hi 也是看不下去了，决定来开导开导小 Ho：“小 Ho，你有没有想过，在之前的计算中，计算出以每一个位置为中心的最长回文子串的长度有没有什么用呢？”

   小 Ho 答道：“我想想，如果以第 5 个字符为中心的最长回文子串的长度是 5 的话，这就告诉了我 [3, 7] 这一段是一个回文子串，所以呢？”

   小 Hi 继续提示道：“假设这时候你想要计算以第 6 个字符为中心的最长回文子串的长度，你有没有什么已知的信息了？”

   小 Ho 边想边说道：“唔，首先第 6 个字符和第 4 个字符是一样的，第 7 个字符和第 3 个字符是一样的，而第 5 个字符本身就肯定和第 5 个字符一样，那么如果 [3, 5] 这一段是回文子串的话，那么 [5, 7] 这一段肯定也是回文子串。也就是说，如果令 f[i] 表示以第 i 个字符为中心的最长回文子串的长度，我们就会有 f[i] >= f[i–2]？”

   “不对，还要考虑到 f[i – 1] 的值，如果 f[i – 1] 太小就没有意义了，应该是 f(i)≥min⁡{f(i-2), f(i-1)-2}。” 小 Ho 接着补充道。

   “没错，但是还有一个问题，如果此时我告诉你 f(5) = 1，但是 f(4) = 7, f(2) = 3 呢？” 小 Hi 追问道。

   小 Ho 想了想，回答道：“理论上来说，我可以通过这些信息知道 f(6)>=3，但是由于 f(5)=1 所以我只能计算出来 f(6)>=-1 我知道了，我不应该是通过 f(i – 1) 来辅助计算，而是通过使得右边界（j + f(j) / 2）最大的那个 j 来辅助计算才是，所以公式将变成 f(i) ≥ min{f(2*j-i) , f(j) -2*(i-j)} 这种形式了！”

   小 Hi 继续问道：“那知道了这个公式之后，你打算怎么做呢？”

   小 Ho 想也没想便道：“这简单，我只要在之前枚举中心位置那种方法的基础上，统计使得回文串右边界（j + f(j) / 2）最大的那个 j，然后再计算每一个 i 的时候，都可以通过 f(i)≥min⁡{f(2*j-i), f(j)-2*(i-j)} 这个公式来知道 f(i) 的一个最小值，这样即使是在我们所提到的那种最坏情况下，也可以节省掉很多不必要的计算呢～


   提示三
   小 Ho 这一想就是三天，小 Hi 也是看不下去了，决定来开导开导小 Ho：“小 Ho，你有没有想过，在之前的计算中，计算出以每一个位置为中心的最长回文子串的长度有没有什么用呢？”

   小 Ho 答道：“我想想，如果以第 5 个字符为中心的最长回文子串的长度是 5 的话，这就告诉了我 [3, 7] 这一段是一个回文子串，所以呢？”

   小 Hi 继续提示道：“假设这时候你想要计算以第 6 个字符为中心的最长回文子串的长度，你有没有什么已知的信息了？”

   小 Ho 边想边说道：“唔，首先第 6 个字符和第 4 个字符是一样的，第 7 个字符和第 3 个字符是一样的，而第 5 个字符本身就肯定和第 5 个字符一样，那么如果 [3, 5] 这一段是回文子串的话，那么 [5, 7] 这一段肯定也是回文子串。也就是说，如果令 f[i] 表示以第 i 个字符为中心的最长回文子串的长度，我们就会有 f[i] >= f[i–2]？”

   “不对，还要考虑到 f[i – 1] 的值，如果 f[i – 1] 太小就没有意义了，应该是 f(i)≥min⁡{f(i-2), f(i-1)-2}。” 小 Ho 接着补充道。

   “没错，但是还有一个问题，如果此时我告诉你 f(5) = 1，但是 f(4) = 7, f(2) = 3 呢？” 小 Hi 追问道。

   小 Ho 想了想，回答道：“理论上来说，我可以通过这些信息知道 f(6)>=3，但是由于 f(5)=1 所以我只能计算出来 f(6)>=-1 我知道了，我不应该是通过 f(i – 1) 来辅助计算，而是通过使得右边界（j + f(j) / 2）最大的那个 j 来辅助计算才是，所以公式将变成 f(i) ≥ min{f(2*j-i) , f(j) -2*(i-j)} 这种形式了！”

   小 Hi 继续问道：“那知道了这个公式之后，你打算怎么做呢？”

   小 Ho 想也没想便道：“这简单，我只要在之前枚举中心位置那种方法的基础上，统计使得回文串右边界（j + f(j) / 2）最大的那个 j，然后再计算每一个 i 的时候，都可以通过 f(i)≥min⁡{f(2*j-i), f(j)-2*(i-j)} 这个公式来知道 f(i) 的一个最小值，这样即使是在我们所提到的那种最坏情况下，也可以节省掉很多不必要的计算呢～

